<style>

/* By default, make all images center-aligned, and 60% of the width
of the screen in size */
img
{
    display:block;
    float:none;
    margin-left:auto;
    margin-right:auto;
    width:90%;
}

/* Create a CSS class to style images to 90% */
.fullPic
{
    display:block;
    float:none;
    margin-left:auto;
    margin-right:auto;
    width:100%;
}

/* Create a CSS class to style images to 60% */
.normalPic
{
    display:block;
    float:none;
    margin-left:auto;
    margin-right:auto;
    width:60%;
}

/* Create a CSS class to style images to 40% */
.thinPic
{
    display:block;
    float:none;
    margin-left:auto;
    margin-right:auto;
    width:40%;
}

/* Create a CSS class to style images to 20% */
.smallPic
{
    display:inline-block;
    float:left;
    margin-left:none;
    margin-right:none;
    width:150px;
}

/* Create a CSS class to style images to left-align, or "float left" */
.leftAlign
{
    display:inline-block;
    float:left;
    /* provide a 15 pixel gap between the image and the text to its right */
    margin-right:15px;
}

/* Create a CSS class to style images to right-align, or "float right" */
.rightAlign
{
    display:inline-block;
    float:right;
    /* provide a 15 pixel gap between the image and the text to its left */
    margin-left:15px;
}
.image-caption {
  text-align: center;
  font-size: 1.0rem;
}

</style>

## 1. Теоретические основы

### 1.1. Микропрограммные автоматы

> ***Микропрограммный автомат*** — это цифровое устройство, которое реализует алгоритм управления в виде последовательности микрокоманд. 

Каждая микрокоманда представляет собой набор управляющих сигналов, которые активируются в определенном состоянии автомата. В отличие от автоматов схемного типа, в микропрограммном автомате микрокоманды хранятся в адресной памяти. Это обеспечивает высокую компактность и быстродействие.  

Структура типичного микропрограммного автомата показана на рисунке 1.

<img src="assets/micro_fsm.svg" alt="Структура микропрограммного устройства управления" style="width:450px;"/>

{:.image-caption}
**Рисунок 1 — Структура микропрограммного устройства управления**

На схеме приняты следующие сокращения: 
- `РгК` – регистр команды хранит текущую команду, которая была получена от внешнего устройства (например, процессора или контроллера);
- `КОП` – код операции определяет тип операции, которую нужно выполнить; 
- `СхФАПМк` – схема формирования адреса первой микрокоманды вырабатывает адрес первой микрокоманды в памяти микропрограмм;
- `СхФАМк` – схема формирования адреса микрокоманды определяет адрес очередной микрокоманды на основе текущей микрокоманды и осведомительных сигналов;
- `РгАМк` – регистр адреса микрокоманды хранит адрес текущей микрокоманды в памяти микропрограмм (ПМп);
- `ПМп` – память микропрограмм хранит набор микрокоманд, каждая из которых представляет собой двоичное управления;
- `РгМк` – регистр микрокоманды хранит текущую микрокоманду, которая была выбрана из памяти микропрограмм;
- `СхДкМк` – схема декодирования микрокоманд преобразует управляющие сигналы из микрокоманды в конкретные управляющие воздействия;
- `ОБ` – операционный блок не относится к микропрограммному автомату, а является целевым устройством, подлежащим управлению. Операционный блок выполняет различные операции на основе управляющих сигналов микрокоманды.

Микропрограммный автомат выполняет циклическую выборку кодов микрокоманд из памяти микропрограмм. Цикл работы микропрограммного автомата состоит из следующих этапов: 
- Команда загружается в регистр команды (`РгК`).
- Код операции (КОП) передается в схему формирования адреса первой микрокоманды (`СхФАПМк`).
- СхФАПМк формирует адрес первой микрокоманды и загружает его в регистр адреса микрокоманды (`РгАМк`).
- На основе адреса из РгАМк выбирается микрокоманда из памяти микропрограмм (`ПМп`).
- Микрокоманда загружается в регистр микрокоманды (`РгМк`).
- Схема декодирования микрокоманд (`СхДкМк`) преобразует управляющие сигналы из РгМк в управляющие воздействия для операционного блока (`ОБ`).
- Операционный блок (`ОБ`) выполняет операцию и возвращает результат и осведомительные сигналы.
- Схема формирования адреса микрокоманды (`СхФАМк`) определяет адрес следующей микрокоманды на основе осведомительных сигналов и текущей микрокоманды.
- Адрес загружается в регистр адреса микрокоманды (`РгАМк`), и процесс повторяется.

Микропрограммные автоматы обладают рядом преимуществ в сравнении с автоматами со схемной логикой:
- Легко изменять алгоритм управления, модифицируя микропрограммы.
- Компоненты микропрограммного автомата можно разрабатывать и тестировать независимо.
- Логика переходов и управляющие сигналы легко отслеживаются и модифицируется.
- Возможно реализовать динамическое микропрограммирование, когда содержимое памяти микропрограмм и памяти адресов первых микрокоманд перезаписывается извне. 

Для изучения и использования языка описания микропрограммных автоматов, необходимо разобрать его синтаксис и основные конструкции. 

<!-- 
```js
                                           
    /--------------------------<<-Адрес следующей микрокоманды-<<---------------------------------\
    |                                                                                             |   
    |                  Код микрокоманды                                                           |
    |                           \                          rst >--\                               |
    |                            \ Адрес перехода 0              --o--                            |
    |    Память микрокоманд      2*-----------------------------|  R  |                           |
    |    ------------------       |Маска fbs_mask0   -----      |     |                           |
    |   |     ucmdRAM      |     1*-----------------|M    |     |  &  |--                         |
    |   |                  |      |Шаблон fbs0      |     |     |     |  |                        |
    \---| A_RD             |     0*-----------------|T   F|--*--|     |  |       ---              |
        |                  |      |                 |     |  |   -----   \------|   |             |
      o-| Порт WR  Порт RD |->>---|         fbs >---|F   *|  |        ...       |   |             |
        |                  |      |Адрес перехода 0  -----   |   -----   /------| 1 |-----\       | 
      o-| WE               |     5*--------------------------O--|     |  |      |   |     |       |
        |       clk        |      |Маска fbs_mask1   -----   |  |     |  |    /-|   |     |       |
         -----------|------      4*-----------------|M    |  |  |  &  |--/    |  ---      |       |
 clk >--------------              |Шаблон fbs1      |     |  |  |     |       |   /       |       |
                                 3*-----------------|T   F|*-O--|  R  |       |  побитно  |       |
                                  |                 |     || |   --o--        |           |       |
 fbs >>                           |         fbs >-/-|F   *|| |      \--< rst  |           | |\    |
 rst >>                           |              /   ----- | |                |           | | \   |
                                  |         ucmd_fbs       | |    ---         |           | |  \  |
                                  |                        | \---|   |   ---  |           \-|0  | |
                                  *-   ...                 \-----| 1 |o-|   | |             |MUX|-/
                                  *- ...      --"--        ...---|   |  |   | |           /-|1  |
                                  *-   ...                        ---   | & |-/           | | A/
                                  |                                     |   |             | | /
                                 6*----- >> Адрес @DEFAULT >> ---/------|   |             | |/|
                                  |                             /        ---              |   |
                                 7*---- >> ucmd_c          Адрес перехода по умолчанию    |   |
                                  Управляющая часть микрокоманды                          |   |
    clk >------------                                                                     |   |
                     \                                                                    |   |
                  ----/------                                                             |   |
                 |   clk     |                                                            |   |     
                 |           |                     Адрес первой микрокоманды              |   |
    cmd >--------|A ucmdARAM |------------------------------------------------------------/   |
                 |           |                                                                |
                 |           |                                                                |
                  -----------                                                                 |
    Схема формирования адреса первой микрокоманды                                             |
                                                            Сигнал "Старт микропрограммы"     |
    run >-------------------------------------------------------------------------------------/

    
    * - F = and (!((Ti = Fi) and Mi))
``` -->

### 1.2. Язык ucmd для описания микропрограммных автоматов

Для упрощения разработки и отладки микропрограммных автоматов на кафедре ИУ6 разработан язык микропрограммирования ucmd (язык описания микропрограмм), а также одноименный компилятор. В данном разделе рассмотрим правила описания автоматов, а в разделе `1.3` рассмотрим средства компиляции и результаты их работы.   

> Язык `ucmd` позволяет описать микропрограммный автомат (МПА) с определенными характеристиками, которые делают его удобным для проектирования и моделирования управляющих автоматов. 

Язык `ucmd` позволяет:
1. Описывать управляющие, осведомительные и командные сигналы.
2. Задавать состояния и переходы между ними.
3. Использовать битовые операции и логические выражения.
4. Описывать микропрограммы как последовательности состояний и переходов.
5. Поддерживать комментарии для улучшения читаемости.

Это делает `ucmd` удобным инструментом для проектирования и моделирования микропрограммных автоматов.

Микропрограмма `ucmd` состоит из следующих секций, расположенных в произвольной последовательности:
- Описание сигналов (управляющих `@CONTROL`, осведомительных `@FEEDBACK`, команд `@CMD` и т.д.).
- Описание начального состояния (`@IDLE0`).
- Описание микропрограмм (состояний и переходов).


#### 1.2.1. Описание сигналов

Рассмотрим правила описания сигналов:

- Сигналы описываются в специальных секциях, которые начинаются с ключевого слова `@` (например, `@CONTROL`, `@FEEDBACK`).
- Состояния задаются правильными именами идентификаторов  (например, `IDLE0`, `ex_0`).
- Условия переходов записываются с помощью `@IF`.
- Переход по умолчанию задается с помощью `@DEFAULT`.
- Начальное состояние микропрограммного автомата фиксировано, и задается именем `IDLE0`.
- Значения сигналов задаются в двоичном формате (например, `"00001"`) или в виде числовых или строчных констант (например, `1`, `8h"0d"`, `s"l"`).

**1.2.1.1. Управляющие сигналы**

> Управляющие сигналы используются для воздействия на операционное устройство.

```js
@CONTROL
    signal_name<start:end>;  // Многобитный сигнал
    signal_name;             // Однобитный сигнал
```
- `signal_name` — имя сигнала.
- `<start:end>` — диапазон битов (например, `control<0:4>` означает 5-битный сигнал).

Значение `start` может быть больше, меньше или равно значению `end`. 

Пример:
```js
@CONTROL
    control<0:4>;  // 5-битный управляющий сигнал в формате lsb:msb
    ucmd_ready<0:0>;  // 1-битный управляющий сигнал
    ucmd_state<1:0>;  // 2-битный управляющий сигнал в формате msb:lsb
    mpu_ready;    // Однобитный сигнал
```

Формат задания диапазона сигналов в шинах е имеет существенного значения, так как компилятор ucmd преобразует описание шины в описание отдельных сигналов. Например, описание сигналов `control`, `ucmd_ready` и `ucmd_state` будет преобразовано в описание отдельных сигнальных линий с именами, состоящими из имени шины, конкатенированных с номерами линий:

```js
@CONTROL
    control0; control1; control2; control3; control5; 
    ucmd_ready0;
    ucmd_state1; ucmd_state0;
    mpu_ready;
```


**1.2.1.2. Осведомительные сигналы**

> Осведомительные сигналы используются для получения информации о состоянии управляемого устройства.

Секция описания осведомительных сигналов: 

```js
@FEEDBACK
    signal_name<start:end>;  // Многобитный сигнал
    signal_name;             // Однобитный сигнал
```

Пример:

```js
@FEEDBACK
    feedback<4:0>;  // 5-битный осведомительный сигнал
```

**1.2.1.3. Сигналы команды**

> Командные сигналы определяют, какую микропрограмму нужно выполнить.

Секция описания командного слова описывается следующим образом: 

```js
@CMD
    signal_name<start:end>;  // Многобитный сигнал
```
Пример:

```js
@CMD
    cmd<4:0>;  // 5-битный сигнал команды
```

**1.2.1.4. Сигнал старта микропрограммы**

> Сигнал старта микропрограммы разрешает запуск микропрограммы.

Секция описания сигнала старта микропрограмм показана ниже:

```js
@RUN
    signal_name;
```
Пример:

```js
@RUN
    start;  // Сигнал разрешения запуска
```

В секции должен быть представлен только один сигнал, имя которого совпадает с внешним сигналом "Старт микропрограммы". 

Запуск новой микрокоманды означает переход из состояния `IDLE0` в одну из микропрограмм, представленных в коде `ucmd`. Поэтому, запуск микропрограммы предполагется и возможен только в том случае, если микропрограммный автомат находится в состоянии ожидания.

Для каждого микропрограммного автомата создается дополнительный сигнал `busy`, который равен `1` только если микропрограммный автомат находится в состоянии ожидания `IDLE0`.

#### 1.2.2. Начальное состояние

Начальное состояние представлено секцией `IDLE0`. Описание секции не отличается от описания обычного состояния, однако может содержать гораздо большее количество переходов. Предполагается, что аппаратная реализация начального состояния выполнена на основе памяти адресов микропрограмм. Поэтому, если микропрограммный автомат находится в состоянии `IDLE0` и в этом такте поступает активный сигнала "Старт микропрограммы", объявленный в секции  `@RUN`, то адрес следующей микрокоманды выбирается из памяти адресов микропрограмм, а не на основе термов и логики формирование адреса следующей микрокоманды.
  
Пример описания начального состояния:
```js
IDLE0:
    mpu_ready = 1;     // Сигнал готовности в начальном состоянии установлен в 1
    cmd<3:0> = 4h"0";  // Микропрограмма 0
    cmd<3:0> = 4h"1";  // Микропрограмма 1
    cmd<3:0> = 4h"2";  // Микропрограмма 2
    cmd<3:0> = 4h"3";  // Микропрограмма 3
    cmd<3:0> = 4h"4";  // Микропрограмма 4
    cmd<3:0> = 4h"5";  // Микропрограмма 5
    cmd<3:0> = 4h"d";  // Микропрограмма d
```

#### 1.2.3. Описание микропрограмм

Файл `ucmd` содержит описание одной и более микропрограмм. Каждая микропрограмма представляет собой последовательность состояний и переходов между ними. Для каждого состояния микропрограммы задается микрокоманда.  

**1.2.3.1. Состояния**

Состояние задается меткой и описанием значений сигналов:

```js
STATE_NAME:
    signal_name = value;  // явная установка значений сигналов (микрокоманда)
    @DEFAULT => NEXT_STATE;  // Переход по умолчанию
```
 Сигналы, не устанавливаемые в состоянии явно (в отличие от явной установки `signal_name = value;`), считаются пассивными, т.е. устанавливаются в `0`. 

Пример:
```js
EX_0:
    control<4:1> = "0001";  // Установка управляющих сигналов
    @DEFAULT => EX_0_STATE1;  // Переход по умолчанию
```

В приведенном примере сигнал `control0` устанавливается в значение `0`.

**1.2.3.2. Переходы**

Переходы между состояниями задаются с помощью условий:

```js
@IF (condition) => NEXT_STATE;
```
- `condition` — логическое выражение конъюнкции осведомительных сигналов, которое может включать описание термов над сигналами и их значениями.
- `NEXT_STATE` — состояние, в которое произойдет переход, если условие терма истинно.

Терм (элементарная конъюнкция) может содержать один и более осведомительных сигнала, между которыми записывается символ конъюнкции `&`. 

Пример:
```js
@IF (feedback<4> = 0 & feedback<0> = 1) => IDLE0;  // Переход, если feedback<4> равен 0 и feedback<0> равен 1
```

Для приведенного терма указаны лишь два сигнала, которые определяют условие перехода в состояние `IDLE0`. Все остальные осведомительные сигналы, описанные в начальной секции `@FEEDBACK` маскированы для данного терма, т.е. не выполняется их сравнение с каким-либо шаблонным значением. 


**1.2.3.3. Множественные переходы**

В одном состоянии может быть несколько переходов, которые проверяются последовательно:
```js
STATE_NAME:
    @IF (condition1) => NEXT_STATE1;
    @IF (condition2) => NEXT_STATE2;
    @DEFAULT => DEFAULT_STATE;  // Переход по умолчанию
```
Пример:
```js
EX_1_STATE1:
    @IF (feedback<2:1> = "00" & feedback<0> = 1) => EX_1_FB1;
    @IF (feedback<2> = 0 & feedback<1> = 1 & feedback<0> = 0) => EX_1_FB2;
    @DEFAULT => EX_1_STATE1;  // Остаться в текущем состоянии
```

Из такой схемы видно, что переходы могут быть описаны так, что их условия  пересекаются. Например, два условия следующих термов пересекаются, что вызовет предупреждение при попытке компиляции: 

```js
EX_1F_STATE1: 
	@IF (feedback<3:2>="01") => IDLE0;
	@IF (feedback<4>=1) => EX_1F;
	@DEFAULT => EX_1F_STATE1;
```
Потенциальной ошибкой является пересечение условий термов, если они ведут в различные состояния. В итоге, компилятор `ucmd` выдаст следующее предупреждение: 

```bash
Анализ термов в состоянии EX_1F_STATE1. Обнаружено пересечение терма 1 (=>IDLE0) и терма 2 (=>EX_1F)
```

Напротив, если состояния переходов идентичны, такое описание вполне допустимо и сообщение не выдается: 

```js
EX_1F_STATE1: 
	@IF (feedback<3:2>="01") => EX_1F;
	@IF (feedback<4>=1) => EX_1F;
	@DEFAULT => EX_1F_STATE1;
```

#### 1.2.4. Переход по умолчанию

Если ни одно из условий перехода не выполнено, используется переход по умолчанию:

```js
@DEFAULT => STATE_NAME;
```

Пример:

```js
@DEFAULT => IDLE0;  // Переход в начальное состояние
```

#### 1.2.5. Символьные и числовые константы

Конструкции `s"..."` и `h"..."`  используются для работы с символьными и числовыми данными. Они позволяют задавать значения сигналов в удобном формате. 

Конструкция `s"..."` используется для задания двоичных значений на основе ASCII последовательности символов. Она интерпретирует строку симоволов внутри кавычек как 8-битные ASCII-коды и преобразует его в двоичное представление. Размер константы равен количеству бит для записи указанной строки (количество символов * 8).

Пример:

```js
   putchar<15:0>=s"Hl";  // Устанавливает сигнал putchar в значение ASCII-кода 'H' (01001000 в двоичном виде) и символа 'l' (01101100 в двоичном виде), т.е. "0100100001101100"
```

Конструкция `h"..."` используется для задания числового значения в шестнадцатеричном формате. Она интерпретирует строку внутри кавычек как шестнадцатеричное число и преобразует его в двоичное представление. Перед конструкцией указывается количество двоичных разрядов. 

Синтаксис шестнадцатеричной константы показан ниже: 

```js
<разрядность>h"<шестнадцатеричное_число>"
```
- Конструкция **`<разрядность>h"..."`** поддерживает шестнадцатеричные числа.
- **`<разрядность>`** — количество бит, которые будут использованы для представления числа (например, `8h` означает 8 бит).
- **`<шестнадцатеричное_число>`** — число в шестнадцатеричном формате (например, `"0d"`).
- Разрядность должна соответствовать размеру сигнала. Например, для 8-битного сигнала используется `8h`, для 5-битного — `5h`.

Примеры: 

1. Шестнадцатеричное число `"0d"`:
   ```js
   putchar<7:0>=8h"0d";  // Устанавливает сигнал putchar в значение 0x0D (00001101 в двоичном виде)
   ```
2. Шестнадцатеричное число `"1F"`:
   ```js
   control<4:0>=5h"1F";  // Устанавливает сигнал control в значение 0x1F (11111 в двоичном виде)
   ```
#### 1.2.6. Пример полной программы

```js
//Описание управляющих сигналов автомата
@CONTROL
	control<0:4>;
	mpu_ready;
	//Состояние сигналов по умолчанию: 1'b0

//Описание осведомительных сигналов автомата
@FEEDBACK
	feedback<4:0>;

//Сигналы кода команды
@CMD
	cmd<4:0>;

//Сигнал разрешения запуска микропрограммы
@RUN
	start;


//Начальное состояние
IDLE0:
	control<4:0>=5h"00";
	mpu_ready=1;

//Описание микропрограмм
//0x00 Микропрограмма 0
@IF (cmd<4:0>=5h"00") => EX_0;
//0x01 Микропрограмма 1
@IF (cmd<4:0>=5h"01") => EX_1;
//0x02 Микропрограмма 2
@IF (cmd<4:0>=5h"02") => EX_2;
//0x1F Микропрограмма 31
@IF (cmd<4:0>=5h"1f") => EX_1F;

//Переход по умолчанию
@DEFAULT => IDLE0;

/////////////////////////////
//	   Микропрограмма 0    //
/////////////////////////////

EX_0: //

	control<4:0>=5h"01";
	@DEFAULT => EX_0_STATE1;

EX_0_STATE1:  //

	@IF (feedback<0>=1) => IDLE0;
	@DEFAULT => EX_0_STATE1;

/////////////////////////////
//	   Микропрограмма 1    //
/////////////////////////////

EX_1: //

	control<4:0>=5h"02";
	@DEFAULT => EX_1_STATE1;

EX_1_STATE1:  //Множественные переходы

	@IF (feedback<2:1>="00" & feedback<0>=1) => EX_1_FB1;
	@IF (feedback<2>=0 & feedback<1>=1 & feedback<0>=0) => EX_1_FB2;
	@IF (feedback<2>=0 & feedback<1:0>="11") => EX_1_FB3;
	@IF (feedback<2>=1 & feedback<1:0>="00") => EX_1_FB4;
	@DEFAULT => EX_1_STATE1;

EX_1_FB1: //

	control<4:0>="00010";
	@DEFAULT => IDLE0;

EX_1_FB2: //

	control<4:0>="00100";
	@DEFAULT => IDLE0;

EX_1_FB3: //

	control<4:0>="01000";
	@DEFAULT => IDLE0;

EX_1_FB4: //

	control<4:0>="10000";
	@DEFAULT => IDLE0;

/////////////////////////////
//	   Микропрограмма 2    //
/////////////////////////////

EX_2: //

	control<4:0>="10011";
	@DEFAULT => EX_2_STATE1;

EX_2_STATE1:  //Множественные переходы

	@IF (feedback<2:0>="001") => EX_2_FB1;
	@IF (feedback<2:0>="010") => EX_2_FB2;
	@IF (feedback<2:0>="011") => EX_2_FB3;
	@IF (feedback<2:0>="100") => EX_2_FB4;
	@DEFAULT => EX_2_STATE1;

EX_2_FB1: //

	control<4:2>="111";
	control<1:0>="01";
	@DEFAULT => IDLE0;

EX_2_FB2: //

	control<4:0>="11011";
	@DEFAULT => IDLE0;

EX_2_FB3: //

	control<4:0>="10111";
	@DEFAULT => IDLE0;

EX_2_FB4: //

	control<4:0>="01111";
	@DEFAULT => IDLE0;


/////////////////////////////
//	   Микропрограмма 1F   //
/////////////////////////////

EX_1F: //

	control<4:0>="11111";
	@DEFAULT => EX_1F_STATE1;

EX_1F_STATE1:  //

	@IF (feedback<4:3>=2h"01") => IDLE0;
	@IF (feedback<4>=1) => EX_1F;
	@DEFAULT => EX_1F_STATE1;
```

Диаграмма переходов состояний для приведенного автомата показана ниже: 

<img src="assets/example_fsm.svg" alt="Диаграмма переходов состояний автомата"/>

{:.image-caption}
**Рисунок 2 — Диаграмма переходов состояний автомата**


### 1.3. Компилятор ucmd

Процесс компиляции файла микропрограмм производится в несколько этапов. 
1. На первом этапе описание автомата подвергается обработке для преобразования констант и векторов в скалярные сигналы и бинарные значения. 
2. Далее выполняется разбор полученного описания, и формирование в памяти графа переходов микрокоманд. На следующем этапе граф подвергается ряду проверок на достижимость состояний, отсутствии пересечений термов и ряда других. 
3. На третьем этапе начинается генерация кода: на основе графа микропрограмм происходит генерация карт памяти адресов первых микрокоманд и микрокомандной памяти. 
4. На следующем этапе происходит генерация Verilog описания устройства микропрограммного управления на основе шаблона. В ходе этого этапа в шаблон добавляется информация о количестве и именах сигналов, о именах файлом для инициализации памяти, генерируется шаблон для отладки микропрограммного автомата. 
5. На последнем этапе генерируется файл в формате dot для визуализации диаграммы переходов состояний. 

Рассмотрим процесс компиляции устройства микропрограммного управления более подробно. 

#### 1.3.1. Запуск компилятора

Компилятор ucmd принимает на вход шесть аргументов:

```bash
ucmd <source> <name> <verilog> <mcmem> <adrmem> <dot>
```

Аргументы компилятора:

1. **`source`** — исходный файл с описанием микропрограмм на языке `ucmd`.
2. **`name`** — имя генерируемого модуля (будет использоваться в Verilog-коде).
3. **`verilog`** — имя выходного Verilog-файла, содержащего описание микропрограммного автомата.
4. **`mcmem`** — файл для записи карты памяти микропрограмм.
5. **`adrmem`** — файл для записи карты памяти адресов микропрограмм.
6. **`dot`** — файл для записи микропрограммы в формате **DOT** (графическое представление).


Например:

```bash
ucmd source.ucmd micro01 micro.v micro.mcmem micro.adrmem micro.dot
```

#### 1.3.2. Преобразование констант и векторов в скалярные сигналы и бинарные значения

На этом этапе компилятор обрабатывает исходное описание автомата:
- **Константы** (например, `s"l"`, `8h"0d"`) преобразуются в их двоичное представление.
  - `s"l"` → `01101100` (ASCII-код символа `'l'`).
  - `8h"0d"` → `00001101` (шестнадцатеричное значение `0x0D`).
- **Векторные сигналы** (например, `control<4:0>`, `feedback<4:0>`) разбиваются на отдельные биты или группы битов.
  - `control<4:0>` → `control4`, `control3`, ..., `control0`.
- **Управляющие и осведомительные сигналы** приводятся к единому формату для дальнейшей обработки.

#### 1.3.3. Разбор описания и формирование графа переходов

На этом этапе компилятор:
- Анализирует описание микропрограмм, состояний и переходов.
- Строит граф переходов, где вершины — это состояния автомата (например, `IDLE0`, `EX_0`, `H`), а ребра - это переходы между состояниями, которые зависят от условий (например, `@IF (feedback<0>=1) => IDLE0`).

В ходе лексического анализа кода компилятор читает исходный файл и разбивает его на токены (ключевые слова, идентификаторы, числа, символы и т.д.).  Если лексический анализ завершается успешно, выводится сообщение:
  ```js
  Лексический анализ завершился. Ошибок не обнаружено!
  ```
Далее выполняется синтаксический анализ, в ходе которого компилятор проверяет, соответствует ли последовательность токенов правилам языка `ucmd`. Если синтаксический анализ завершается успешно, выводится сообщение:
  ```js
  Синтаксический анализ выполнен. Ошибок не обнаружено!
  ```

#### 1.3.4. Проверки графа:
- **Достижимость состояний**: Проверяется, что все состояния могут быть достигнуты из начального состояния. Если состояние недостижимо, компилятор выдает предупреждение или ошибку.
- **Отсутствие пересечений термов**: Проверяется, что условия переходов в одном состоянии не пересекаются (например, два перехода не могут быть активны одновременно при одинаковых условиях).
- **Корректность переходов**: Проверяется, что все переходы ведут к существующим состояниям.

Цель выполнения данного этапа - построение корректного граф переходов, который будет использоваться для генерации кода.

#### 1.3.5. Генерация карт памяти

На этом этапе компилятор генерирует:
- **Карту памяти микрокоманд**. Каждая микрокоманда кодируется в виде двоичного значения.
- **Карту памяти адресов**. Файл содержит адреса первых микрокоманд для каждой команды (начальная микрокоманда для каждой микропрограммы).

В случае успешной генерации карт памяти выдается следующее сообщение: 

  ```js
  Генерация карты памяти...OK!
  ```


#### 1.3.6. Генерация Verilog-кода

На этом этапе компилятор:
- Использует **шаблон Verilog-кода** для генерации описания микропрограммного автомата.
- Добавляет в шаблон:
  - Имена и количество сигналов (управляющих, осведомительных, командных).
  - Имена файлов для инициализации памяти (файлы `*.mcmem`, `*.adrmem`).
  - Шаблон для отладки микропрограммного автомата (например, подключение ChipScope и соответствие имен состояний адресам микрокоманд).

В итоге записывается готовый к использованию Verilog-код, который можно синтезировать или включить в проект FPGA.

#### 1.3.7. Генерация DOT-файла

На этом этапе компилятор:
- Создает файл в формате **DOT**, который описывает граф переходов состояний.
- Пример содержимого файла `*.dot`:
  ```js
  digraph example {
      IDLE0 -> H [label="cmd0=0"];
      H -> H_w [label="wready=1"];
      H_w -> e [label="wready=1"];
  }
  ```

#### 1.3.8. Визуализация DOT-файла

Файл `*.dot` можно визуализировать с помощью инструмента **Graphviz**, например следующим образом:

```bash
dot -Tpng micro.dot -o micro.png
```
Это создаст изображение `*.png`, на котором будет показана диаграмма состояний и переходов микропрограммного автомата.

В итоге генерируется графическое представление автомата для удобства его анализа и отладки.

#### 1.3.9. Отчет компилятора

После завершения компиляции в консоль выводится отчет:

```text
------------------------------------------------------------------
|    Программа для создания микропрограммых автоматов            |
|    Использование: ucmd <1> <2> <3> <4> <5>                     |
|    <1> - Исходный файл с описанием микропрограмм               |
|    <2> - Имя генерируемого модуля                              |
|    <3> - Имя Verilog файла автомата                            |
|    <4> - Файл для записи карты памяти микропрограмм            |
|    <5> - Файл для записи карты памяти адресов микропрограмм    |
|    <6> - Файл для записи микропрограммы в формате DOT          |
|                                                                |
|           Version 1.6. IU6, BMSTU                              |
------------------------------------------------------------------
Openning program file ./ucmd_regex/_uart_regex.ucmd
Лексический анализ завершился.  Ошибок не обнаружено!
Синтаксический анализ выполнен. Ошибок не обнаружено!
Генерация карты памяти...OK!
Количество состояний                  :8
Максимальное количество термов        :5
Количество сигналов управления        :10
Количество осведомительных сигналов   :15
Размер слова команды (бит)            :1
Размер слова микрокоманды (бит)       :192
Генерация DOT файла!
Генерация завершена!
```

#### 1.3.10. Структура кода микропрограммного автомата на языке Verilog

Результирующий файл микропрограммного автомата готов к синтезу в САПР Xilinx ISE или Vivado. Файл содержит описание нескольких модулей: 

1. **Модуль `ucmd_fsm`**
Это основной модуль, который реализует микропрограммный автомат. Он включает:
- **Параметры**:
  - `ucmd_g`, `ucmd_fbs`, `ucmd_adr`, `ucmd_c`, `cmd_c` — параметры, определяющие размеры сигналов и памяти.
  - `ucmdRAM_data_w`, `ucmdRAM_adr_w` — параметры для настройки памяти микропрограмм.
  - `ucmd_ram_type`, `control_type`, `fpga_type` — параметры, определяющие тип памяти и архитектуру ПЛИС.

- **Порты**:
  - `rst`, `clk` — сигналы сброса и тактового сигнала.
  - `cmd`, `run`, `fbs` — входные сигналы команд, запуска и осведомительных сигналов.
  - `ucmd`, `busy`, `ucmd_state` — выходные сигналы управляющих команд, состояния автомата и флага занятости.

- **Память**:
  - `mcmem` — двухпортовая память для хранения микропрограмм.
  - `adrmem` для хранения адресов микропрограмм.

- **Логика переходов**:
  - Используется либо на основе **CARRY4** (для FPGA семейства Xilinx), либо на основе **LUT** (Look-Up Table).

2. **Модуль `dualport_ram`**: Этот модуль реализует двухпортовую память, которая используется для хранения микропрограмм и адресов. 

3. **Модуль `carry4_chain`**: Этот модуль реализует логику переходов на основе цепей **CARRY4**, которые используются для ускорения вычислений в FPGA.

4. **Модуль `bitwise_logic_x8_with_carry4`**: Этот модуль реализует побитовую логику с использованием **CARRY4** для обработки осведомительных сигналов и формирования адресов переходов.

5. **Модуль `top_ucmd_fsm_<name>`**: Этот модуль является верхним уровнем иерархии. Модуль соединяет все компоненты (микропрограммный автомат, память, логику переходов) и предоставляет интерфейс для взаимодействия с внешними сигналами (команды, осведомительные сигналы, управляющие сигналы).


### 1.4. Методика разработки микропрограммных автоматов `ucmd`

Методика разработки и верификации микропрограммных автоматов с использованием языка `ucmd` состоит в следующем. 

#### 1.4.1. Описание требований

На данном этапе необходимо определить: 

- **управляющие сигналы** (выходные сигналы, которые управляют внешними устройствами);
- **осведомительные сигналы** (входные сигналы, которые предоставляют информацию о состоянии системы);
- **команды** (входные сигналы, которые запускают выполнение микропрограмм);
- **состояния** и **переходы** между ними.

#### 1.4.2. Описание автомата на языке ucmd

Используя язык `ucmd` и прилагаемый шаблон разрабатывается описание микропрограммного автомата.

  ```js
  @CONTROL
      //Сигналы микрокоманды

  @FEEDBACK
      //Осведомительные сигналы

  @CMD
      //Сигналы команды

  @RUN
      //Сигнал старта микропрограммы

  IDLE0:
      //Начальное состояние

      //Команды и переходы на микропрограммы
      @IF ( = "") => ;
      @DEFAULT => IDLE0;

  EX_0:
      //Микрокоманда
       = "";
      @IF (... = "" & ... = "" & ... = "") => ;
      @IF (... = "" & ... = "" & ... = "") => ;
      @DEFAULT => ...;
  ```

#### 1.4.3. Компиляция ucmd-файла

Используйте компилятор `ucmd` для генерации Verilog-кода, карт памяти и DOT-файла.

  ```bash
  ucmd ./ucmd_regex/_uart_regex.ucmd example ./ucmd_regex/uart_regex.v ./ucmd_regex/uart_regex.mcmem ./ucmd_regex/uart_regex.adrmem ./ucmd_regex/uart_regex.dot
  ```

#### 1.4.4. Синтез автомата в САПР ISE

В проекта добавляются сгенерированный Verilog-файл и файлы карт памяти (`*.mcmem`, `*.adrmem`).

